---
title: "Mugencode"
layout: "landing"
---
<style>
  .markdown h1 {
      margin-top: 0;
  }
  #scene-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
  }

  .intro-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow-y: scroll;
      scroll-snap-type: y mandatory;
      z-index: 2;
  }

  section {
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      scroll-snap-align: start;
      position: relative;
      overflow: hidden;
  }

  .content {
      color: var(--body-font-color);
      background-color: var(--card-background);
      padding: 2rem;
      border-radius: 5px;
      max-width: 600px;
      text-align: center;
      z-index: 10;

  }
  .content-card-wide {
      max-width: 850px;
  }
  .content-card-wide h2{
      margin-top: 0;
  }


  #fps-counter {
      position: fixed;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-family: monospace;
      z-index: 1000;
      display: none;
  }

  .skill-list, .project-list, .interest-list {
      text-align: left;
      margin-top: 20px;
  }

  .skill-list li, .project-list li, .interest-list li {
      margin-bottom: 10px;
  }

  @media screen and (max-width: 768px) {
      .navbar-menu {
          position: absolute;
          right: -100%;
          top: 60px;
          flex-direction: column;
          background-color: var(--sec-bg-color);
          width: 100%;
          text-align: center;
          transition: 0.3s;
          box-shadow: 0 10px 27px rgba(0, 0, 0, 0.05);
      }

      .navbar-menu.active {
          right: 0;
      }

      .navbar-menu li {
          margin: 25px 0;
      }

      .burger-menu {
          display: block;
      }

      .burger-menu.active .line1 {
          transform: rotate(-45deg) translate(-5px, 6px);
      }

      .burger-menu.active .line2 {
          opacity: 0;
      }

      .burger-menu.active .line3 {
          transform: rotate(45deg) translate(-5px, -6px);
      }
  }
</style>
<div class="intro-container">
  <section id="about">
    <div class="content content-card-wide">
      <div class="flex align-center">
	<div class="content-card-wide">
	  <h2>Hello! I am Kapil</h3>
	  <p>Business first software generalist.
	  <p>Builder of things & teller of stories.</p>
<p>Curious educator.</p>
	  <p>I love to code on server, client and everything between!</p> 
	</div>
	<div>
	  <img width="500px" src="/images/profile.jpeg"/>
	</div>

      </div>
      <div class="social-links flex justify-center">
        <div><a href="https://github.com/kapilreddy" target="_blank"><svg width="50" color="white" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path fill="#ffffff" d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a></div>
        <div> <a href="https://twitter.com/kapilreddy" target="_blank"><svg color="white" width="50" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>X</title><path fill="#ffffff" d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/></svg></a></div>
      </div>

    </div>
  </section>
  <section id="skills">
    <div class="content content-card-wide">
      <h2>Things I obsses over in no particular order</h2>
      <ul class="skill-list">
        <li>Clojure and functional programming</li>
	<li>Search databases</li>
	<li>Messaging systems</li>
        <li>Migrations of any flavours</li>
	<li>Leading technical platform teams</li>
	<li>Computer graphics and interactive techniques</li>
      </ul>
    </div>
  </section>
  <section id="projects">
    <div class="content content-card-wide">
      <h2>Some of my recent tech side projects</h2>
      <ul class="project-list">
        <li><a href="https://unrealcards.net">Unrealcards</a> - A multiplayer card game written in Clojurescript</li>
	<li><a href="https://github.com/kapilreddy/senju">Senju</a> - An ESP32 and Rust based humidity sensing setup</li>
	<li><a href="https://github.com/kapilreddy/instructor-clj">Instructor-clj</a> - A Clojure implementation of Instructor library. Get structured output and validations from LLMs.</li>
      </ul>
    </div>
  </section>
  <section id="interests">
    <div class="content">
      <h2>Other things I do</h2>
      <p>I am curious about a lot of things and try out. Here are some hobbies that have stuck with me for a while now.</p>
      <p>
        <p>I have made a few short films. You can watch it here. I mostly write screenplays now. Incepting an idea in someone's head is programming in hardest mode. :D</p>
        <p>We have a family farm where we are growing Avocados and Edamame. This has made me appriciate programming and management even more. Everything you do in a farm, the feedback cycles are long and they are always one-way door decisions.</p>
      </p>
    </div>
  </section>
</div>

<div class="navigation">
  <div class="nav-dot" data-section="about"></div>
  <div class="nav-dot" data-section="skills"></div>
  <div class="nav-dot" data-section="projects"></div>
  <div class="nav-dot" data-section="interests"></div>
</div>


<div id="fps-counter">FPS: 0</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  let scene, camera, renderer, particleSystem, trailSystem;
  let currentSection = 0;
  let targetSection = 0;
  let transitionProgress = 1;
  let debugMode = false;
  const clock = new THREE.Clock();

  const bgColor = new THREE.Color( 0x343a40 );
  const PARTICLE_COUNT = 1000;
  const TRAIL_LENGTH = 20;

  const FLOW_SPEED = 0.2;
  const RIVER_WIDTH = 20;
  const RIVER_LENGTH = 100;
  const MEANDER_FREQUENCY = 0.01;
  const MEANDER_AMPLITUDE = 20;
  const TURBULENCE = 0.1;

  // Add this function to create initial positions for the river flow
  function createRiverFlowPositions(particleCount) {
      const positions = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = Math.random() * RIVER_LENGTH - RIVER_LENGTH / 2;
          positions[i * 3 + 1] = (Math.random() - 0.5) * RIVER_WIDTH;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
      }
      return positions;
  }


  function init() {
      document.body.innerHTML += "<div id='scene-container'></div>";

      scene = new THREE.Scene();
      scene.background = bgColor;


      riverFlowPositions = createRiverFlowPositions(PARTICLE_COUNT);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = Math.min(window.innerWidth, window.innerHeight) * 0.7;
      camera.position.z = 50;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById('scene-container').appendChild(renderer.domElement);


      camera.lookAt(0, 0, 0);

      createParticlesAndTrails();
      animate();


  }

  function createParticlesAndTrails() {
      const sphereGeometry = new THREE.SphereGeometry(0.15, 8, 8);
      const sphereMaterial = new THREE.MeshBasicMaterial({
          color: 0xb88dff,
          transparent: true,
          opacity: 0.1
      });

      // Create particles
      particleSystem = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, PARTICLE_COUNT);
      scene.add(particleSystem);

      // Initialize particle positions
      const tempObject = new THREE.Object3D();
      for (let i = 0; i < PARTICLE_COUNT; i++) {
          tempObject.position.set(
	      (Math.random() - 0.5) * 100,
	      (Math.random() - 0.5) * 100,
	      (Math.random() - 0.5) * 100
          );
          tempObject.updateMatrix();
          particleSystem.setMatrixAt(i, tempObject.matrix);
      }
      particleSystem.instanceMatrix.needsUpdate = true;

      // Create trails
      trailSystem = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, PARTICLE_COUNT * TRAIL_LENGTH);
      scene.add(trailSystem);

      // Initialize trail positions
      for (let i = 0; i < PARTICLE_COUNT; i++) {
          for (let j = 0; j < TRAIL_LENGTH; j++) {
	      const index = i * TRAIL_LENGTH + j;
	      tempObject.position.set(
                  (Math.random() - 0.5) * 100,
                  (Math.random() - 0.5) * 100,
                  (Math.random() - 0.5) * 100
	      );
	      tempObject.scale.setScalar(1 - j / TRAIL_LENGTH); // Scale down trail segments
	      tempObject.updateMatrix();
	      trailSystem.setMatrixAt(index, tempObject.matrix);
          }
      }
      trailSystem.instanceMatrix.needsUpdate = true;
  }

  function noise(x, y) {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      const u = fade(x);
      const v = fade(y);
      const A = p[X] + Y, B = p[X + 1] + Y;
      return lerp(v, lerp(u, grad(p[A], x, y), grad(p[B], x - 1, y)),
		  lerp(u, grad(p[A + 1], x, y - 1), grad(p[B + 1], x - 1, y - 1)));
  }

  function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
  function lerp(t, a, b) { return a + t * (b - a); }
  function grad(hash, x, y) {

      const h = hash & 15;
      const u = h < 8 ? x : y,
	    v = h < 4 ? y : h == 12 || h == 14 ? x : 0;
      return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
  }

  const p = new Array(512);
  const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
  for (let i = 0; i < 256; i++) p[256 + i] = p[i] = permutation[i];


  function getTargetPosition(index, section, time) {
      const i = index % PARTICLE_COUNT;
      const t = time * 0.5; // Adjust this multiplier to change overall animation speed
      switch (section) {
      case 0: // About
          return new THREE.Vector3(
	      Math.sin(i / PARTICLE_COUNT * Math.PI * 2 + t) * 40,
	      Math.cos(i / PARTICLE_COUNT * Math.PI * 2 + t) * 40,
	      Math.sin(t + i * 0.1) * 10
          );
      case 1: // Skills
          const angle = i / PARTICLE_COUNT * Math.PI * 2 + t;
          const radius = 30 + Math.sin(t * 2 + i * 0.1) * 10;
          return new THREE.Vector3(
	      Math.cos(angle) * radius,
	      Math.sin(angle) * radius,
	      Math.cos(t + i * 0.1) * 10
          );
      case 2: // Projects
          return new THREE.Vector3(
	      ((i % 30) - 15) * 3 + Math.sin(t + i * 0.1) * 5,
	      (Math.floor(i / 30) - 5) * 5 + Math.cos(t + i * 0.2) * 5,
	      Math.sin(t * 2 + i * 0.1) * 20
          );
      case 3: // Interests
          return new THREE.Vector3(
	      ((i % 30) - 15) * 3 + Math.sin(t + i * 0.1) * 5,
	      (Math.floor(i / 30) - 5) * 5 + Math.cos(t + i * 0.2) * 5,
	      Math.sin(t * 2 + i * 0.1) * 80
          );
	  // getRiverFlowPosition(i, t);
      default:
          return new THREE.Vector3();

      }
  }

  function animate() {
      requestAnimationFrame(animate);

      const time = clock.getElapsedTime();

      if (transitionProgress < 1) {
          transitionProgress += 0.02;
      }

      const tempObject = new THREE.Object3D();
      const tempTrail = new THREE.Object3D();

      for (let i = 0; i < PARTICLE_COUNT; i++) {
          particleSystem.getMatrixAt(i, tempObject.matrix);
          tempObject.position.setFromMatrixPosition(tempObject.matrix);

          const currentTarget = getTargetPosition(i, currentSection, time);
          const nextTarget = getTargetPosition(i, targetSection, time);

          // Interpolate between current section and target section
          const targetPos = new THREE.Vector3().lerpVectors(currentTarget, nextTarget, transitionProgress);

          // Smoothly move towards the target position
          tempObject.position.lerp(targetPos, 0.1);

          // Update particle position
          tempObject.updateMatrix();
          particleSystem.setMatrixAt(i, tempObject.matrix);

          // Update trail with a more pronounced fade effect
          for (let j = TRAIL_LENGTH - 1; j > 0; j--) {
	      const currentIndex = i * TRAIL_LENGTH + j;
	      const prevIndex = i * TRAIL_LENGTH + j - 1;

	      trailSystem.getMatrixAt(prevIndex, tempTrail.matrix);
	      tempTrail.position.setFromMatrixPosition(tempTrail.matrix);

	      // Exponential scale down for more prominent trail fade
	      const scale = Math.pow(0.95, j);
	      //            tempTrail.scale.setScalar(scale);

	      tempTrail.updateMatrix();
	      trailSystem.setMatrixAt(currentIndex, tempTrail.matrix);
          }

          // Set the front of the trail to the current particle position
          tempTrail.position.copy(tempObject.position);
          tempTrail.scale.setScalar(1);
          tempTrail.updateMatrix();
          trailSystem.setMatrixAt(i * TRAIL_LENGTH, tempTrail.matrix);
      }

      particleSystem.instanceMatrix.needsUpdate = true;
      trailSystem.instanceMatrix.needsUpdate = true;

      renderer.render(scene, camera);

      if (debugMode) {
          const fps = Math.round(1 / clock.getDelta());
          document.getElementById('fps-counter').textContent = `FPS: ${fps}`;
      }
  }

  function getRiverFlowPosition(index, time) {
      const ix = index * 3;
      const iy = index * 3 + 1;
      const iz = index * 3 + 2;

      let x = riverFlowPositions[ix];
      let y = riverFlowPositions[iy];
      let z = riverFlowPositions[iz];

      // Update position
      x += FLOW_SPEED;

      // Meandering path
      const meander = Math.sin(x * MEANDER_FREQUENCY + time * 0.2) * MEANDER_AMPLITUDE;
      y += (meander - y) * 0.1;

      // Add some vertical movement
      z += Math.sin(x * 0.02 + time * 0.5) * 0.2;

      // Turbulence
      y += (Math.random() - 0.5) * TURBULENCE;
      z += (Math.random() - 0.5) * TURBULENCE;

      // Reset particles that have flowed past the end
      if (x > RIVER_LENGTH / 2) {
          x = -RIVER_LENGTH / 2;
          y = (Math.random() - 0.5) * RIVER_WIDTH;
          z = (Math.random() - 0.5) * 10;
      }

      // Update the positions array
      riverFlowPositions[ix] = x;
      riverFlowPositions[iy] = y;
      riverFlowPositions[iz] = z;

      return new THREE.Vector3(x, z, y);
  }

  // Modify your init function to create initial river flow positions
  let riverFlowPositions;


  function handleScroll() {
      const container = document.querySelector('.container');
      const scrollPosition = document.documentElement.scrollTop;
      const windowHeight = window.innerHeight;
      
      const newSection = Math.round(scrollPosition / windowHeight);

      if (newSection !== currentSection) {
	  updateNavDots(newSection);
	  scrollToSection(newSection);
      }
  }

  function changeSection(newSection) {
      currentSection = targetSection;
      targetSection = newSection;
      transitionProgress = 0;
  }




  function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function scrollToSection(index) {
      setTimeout(() => {
          document.querySelectorAll('section')[index].scrollIntoView({ behavior: 'auto' });
          updateNavDots(index);
          changeSection(index);

          setTimeout(() => {
	      overlay.classList.remove('active');
          }, 200);
      }, 200);
  }

  function updateNavDots(index) {
      document.querySelectorAll('.nav-dot').forEach((dot, i) => {
          dot.classList.toggle('active', i === index);
      });
  }

  document.addEventListener('DOMContentLoaded', () => {
      init();


      const container = document.querySelector('.container');
      document.addEventListener('scroll', handleScroll);

      document.addEventListener('keydown', (event) => {
          if (event.code === 'Space') {
	      event.preventDefault();
	      const nextSection = (currentSection + 1) % 4;
	      scrollToSection(nextSection);
          } else if (event.code === 'KeyD') {
	      debugMode = !debugMode;
	      document.getElementById('fps-counter').style.display = debugMode ? 'block' : 'none';
          }
      });

      document.querySelectorAll('.nav-dot').forEach((dot, index) => {
          dot.addEventListener('click', () => scrollToSection(index));
      });

      updateNavDots(0);
  }, true);

  window.addEventListener('resize', onWindowResize);
</script>
